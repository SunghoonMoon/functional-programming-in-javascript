# 5장 복잡성을 줄이는 디자인 패턴

### 에러 처리

- 명령형 코드는 try~catch 구문으로 예외를 처리
  ⇒ 에러 처리도 추상화 필요!

<aside>
💡 함수가 null을 반환하면 이 함수를 부른 호출자는 null 체크를 해야 함!

</aside>

### 예외를 던지는 함수의 특징

- 다른 함수형 장치처럼 합성/체이닝 불가
- 예외를 던지는 행위는 함수 호출에서 빠져나갈 구멍을 찾는 것
  ⇒ 참조 투명성 원리에 위배
- 예기치 않게 스택이 풀리면 함수 호출 범위를 벗어나 전체 시스템에 영향
  ⇒ 부수 효과
- 에러가 나면 함수는 지역 스택과 환경에서 벗어남
  ⇒ 에러를 조치하는 코드가 함수를 호출한 지점과 다름
  ⇒ 비지역성 원리에 위배
- catch 블록에서 특정 예외를 붙잡아 처리하면서 낭비
  ⇒ 호출자 부담 가중
- 다양한 에러 조건을 처리하는 블록들이 중첩되어 사용하기 어려움

### 함수형 에러 처리는 위험한 코드 주위에 컨테이너를 설치해서 방어

⇒ 함수형 자료형을 사용하여 불순함과의 분리를 일급 시민으로 만듦

⇒ 값을 안전하게 다루고 프로그램의 불변성이 지켜지도록 직접적인 접근을 차단

---

### 함수자(Functor)

- 값을 Wrapper 안으로 승급한 다음 수정하고 다시 Wrapper에 넣을 목적을 염두에 둔 함수 매핑이 가능한 자료구조
- 함수자는 한 형식의 함수를 다른 형식의 함수로 매핑

### 함수자의 전제 조건

1. 부수효과가 없어야 함
2. 합성이 가능해야 함
   ⇒ 합성 함수에 flatMap을 적용한 것과 flatMap 함수를 체이닝한 것이 동일해야 함

---

### 모나드(Monad)

- 값을 담는 컨테이너의 일종
- Functor를 기반으로 구현되어 있음
- `flatMap()` 메소드를 제공
- Monad Laws를 만족시키는 자료구조

### 모나드형(Monadic type)의 필수 인터페이스

1. 형식 생성자(type constructor): 모나드형을 생성
   ⇒ Wrapper 생성자
2. 단위 함수(unit function): 어떤 형식의 값을 모나드에 삽입
   ⇒ of
3. 바인드 함수(bind function): 연산을 서로 체이닝
   ⇒ flatMap
4. 조인 연산(join operation): 모나드 자료구조의 계층을 평탄화. 모나드 반환 함수를 다중합성 시 특히 중요

### 모나드 장점

- 일반적으로 할 수 없는 여러 상황을 모델링 할 수 있음

1. 값이 없는 상황
2. 값이 미래에 이용가능해질 상황

- 비동기 로직을 동기 로직을 구현하는 것과 동일한 형태로 구현
  ⇒ 함수의 합성 및 완전한 non-blocking pipeline을 구현 할 수 있음
