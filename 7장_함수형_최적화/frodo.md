# 7장 함수형 최적화

> 대략 97%의 경우 어설픈 최적화가 모든 걸 망쳐놓는 원인이 됩니다.
> 하지만 나머지 결정적 3%는 최적화할 기회를 절대로 놓쳐서는 안 됩니다.

- 도널드 커누스
  >

### 최적화는 맨 나중에 한다

⇒ 게임을 제외한 요즘 제작된 웹 애플리케이션은 실행 시간을 몇 밀리초 단축시켰다고 크게 얻을 건 없음

## 함수형 프로그래밍의 최적화

- 개별 함수의 평가 속도를 올리지는 않음
- 함수 중복 호출을 피해 코드가 정말 필요할 때까지 평가를 지연시켜서 최적화
  ⇒ 순수 함수형 언어는 플랫폼 자체로 이러한 최적화를 수행
  ⇒ 자바스크립트는 직접 커스텀 코드나 함수형 라이브러리를 사용해야 함

---

### 함수 콘텍스트 프레임

- 각각 내부 지역 변수의 개수만큼 메모리 점유
- 지역 변수가 하나도 없는 빈 프레임은 48바이트 정도 됨
- scopeChain은 이 함수의 콘텍스트를 그 부모 실행 콘텍스트와 연결하거나 참조
- variableObject는 지역 변수, 함수, 함수의 인수, arguments를 가리키는 속성
  ⇒ 프레임의 크기는 이 속성으로 결정됨!
- 전역 콘텍스트는 단 하나만 존재

⇒ 모든 함수는 스코프 체인이 결국 직/간접적으로 전역 콘텍스트와 연결됨

```jsx
// 함수 콘텍스트 프레임
executionContextData = {
	scopeChain, // 이 함수의 variableObject, 부모 실행 콘텍스트의 variableObject 접근 통로
	variableObject, // 함수의 인수, 내부 변수, 함수 선언부 포함
	this  // 함수 객체를 가리키는 레퍼런스(함수도 결국 객체)
}
```

<aside>
💡 함수의 스코프 체인은 객체의 프로토타입 체인과는 전혀 다름.
스코프 체인은 내부 함수가 자신을 둘러싼 외부 함수의 클로저에 접근할 때 사용하는 연결 고리.
프로토타입 체인은 프로토타입 속성을 통해 객체를 상속할 수 있는 연결 고리

</aside>

### 자바스크립트 함수 실행 특징

- 자바스크립트는 단일 스레드로 작동
  ⇒ 동기 실행(synchronous execution) 방식
- 함수를 호출할 때마다 함수 콘텍스트 스택에 레코드(프레임)가 생성됨
- 전역 콘텍스트는 단 하나만 존재하고 모든 함수 콘텍스트는 전역 콘텍스트를 공유
- 함수 콘텍스트 개수에 제한은 없음 (cf. 클라이언트 측 코드는 브라우저마다 제한 개수가 다름)

### 커링과 함수 콘텍스트 스택

- 어떤 함수를 커리하면, 한 번에 인수를 전부 넣고 평가하는 체제에서 한 번에 인수를 하나씩 받는 함수 호출을 여러 번 하는 체제로 전환
  ⇒ 중첩 구조로 바뀜
  ⇒ 기존보다 함수 스택을 더 많이 사용
- **커링을 과용하면 엄청난 메모리가 소모되면서 프로그램 실행 속도가 현저히 떨어질 수 있음**

```jsx
import * as R from 'ramda';
import _ from 'lodash';

const add = function (a, b) {
  return a + b;
};

const c_add = R.curry(add);

const input = _.range(80000);

function addAll(arr, fn) {
  let result = 0;
  const { length } = arr;
  for (let i = 0; i < length; i++) {
    for (let j = 0; j < length; j++) {
      result += fn(arr[i], arr[j]);
    }
  }
  return result;
}

console.log('start');
console.time('Curry 아닌 경우');
let val = addAll(input, add);
console.log(`결과값 : ${val}`);
console.timeEnd(`Curry 아닌 경우`);

console.time('Curry');
val = addAll(input, c_add);
console.log(`결과값 : ${val}`);
console.timeEnd(`Curry`);
```

![Untitled](7%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE%E1%84%92%E1%85%A7%E1%86%BC%20%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%92%E1%85%AA%20991c8b018ca34714ac4f87e906980605/Untitled.png)

### 재귀 코드의 문제점

- 함수가 자신을 호출할 때에도 새 함수 콘텍스트가 만들어짐
  ⇒ 잘못 구현하면 Stack overflow 발생
- 엄청 큰 용량의 데이터를 재귀로 처리할 때에는 배열 크기만큼 스택이 커질 수 있음
  ⇒ 원소가 아주 많은 리스트는 map, filter, reduce 등의 고계함수를 이용해서 탐색하는 것이 좋음!
  ⇒ 함수 호출을 중첩하지 않고 반복할 때마다 스택을 계속 재활용

---

### 느긋한 평가(lazy evaluation)로 실행을 늦춤

- 가능한 한 오래, 의존하는 표현식이 호출될 때까지 미루는 것
  ⇒ 느긋한 평가로 불필요한 계산을 피할 수 있음
- 자바스크립트는 기본적으로 함수를 조급하게 평가(eager evaluation)함
  ⇒ 함수 결괏값이 필요한지 따져볼 새 없이 변수에 바인딩되자마자 표현식을 평가
  ⇒ 탐욕스런 평가(greedy evaluation)라고도 함

### 대체 함수형 조합으로 계산을 회피

1. 함수를 레퍼런스로 전달하고 조건에 따라 한쪽만 호출
   ex) 함수 조합기 alt → 함수 조합기가 알아서 함수 호출을 관장
2. 단축 융합(shortcut fusion) : 실행 전에 전체 프로그램을 미리 정의해서 최적화를 수행

### 단축 융합

- 몇 개 함수의 실행을 하나로 병합하고 중간 결과를 계산할 때 사용하는 내부 자료구조의 개수를 줄이는 함수 수준의 최적화
  ⇒ 자료구조가 줄면 대량 데이터를 처리할 때 필요한 과도한 메모리 사용을 낮출 수 있음
- 참조 투명성에 관한 함수형 프로그램의 엄격한 규칙 덕분에 가능
  ⇒ 수학적/대수적인 정합 관계가 성립

### 필요할 때 부르리 전략

- 반복적인 계산(특히 자원을 많이 소모하는 계산)을 피하는 것도 실행 속도를 올리는 방법
- 객체지향 시스템 → 함수 호출 전, 캐시나 프록시 계층으로 구현
- 함수형 프로그래밍 → 메모화

### 메모화(메모이제이션)

- 순수 함수형 언어는 자동으로 메모화를 실천.
  자바스크립트나 파이썬에서는 함수를 선택적으로 메모 가능
- 계산 집약적인 함수일수록 효과가 좋음
- 함수형 프로그래밍은 참조 투명성 원리에 의해 같은 매개변수에 대해 동일한 결과값이 나오는 걸 보장!
  ⇒ 메모화를 하면 동일한 입력으로 함수를 재호출할 때 내부 캐시가 히트되어 즉시 결과가 반환
- 자바스크립트의 성능 API 가 대표적인 사용 예

### 메모화 Tip✨

- 인수가 여러 개인 함수는 순수함수라 하더라도 캐시하기가 어려움
  ⇒ 커링으로 메모!
- 코드를 잘게 나눌수록 메모화 효과는 커짐

### 재귀 함수 최적화

1. 메모화를 통해 최적화
   ⇒ 속도 뿐만 아니라 스택 프레임 개수도 줄일 수 있음
2. 컴파일러가 꼬리 재귀 호출(tail call optimization)을 수행하게끔 재귀 알고리즘을 짜면 됨

### 꼬리 재귀 호출(tail call optimization, TCO)

- 꼬리 호출 제거(taill call elimination)라고도 함
- ES6부터 신설된 컴파일러 개선 항목
- 재귀 호출 실행을 단일 프레임으로 눌러 펴 실행
- 재귀 프로그램이 제일 마지막에 다른 함수(보통 자기 자신)를 호출할 경우에만 TCO가 일어남

⇒ 재귀 함수가 가장 마지막 함수에 호출하면, 자바스크립트 런타임은 남은 할 일이 없기 때문에 더 이상 현재 스택 프레임을 붙들고 있을 이유가 없고 그대로 폐기함!
